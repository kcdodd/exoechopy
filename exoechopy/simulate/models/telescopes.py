
"""
This module provides telescopes for acquiring data.
"""

import warnings

import numpy as np
from astropy import units as u
from astropy.utils.exceptions import AstropyUserWarning

from .flares.active_regions import *
from ...utils import *
from .stars import *

__all__ = ['Telescope']

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #


class Telescope:
    """Basic telescope object for acquiring data from a star system."""

    # ------------------------------------------------------------------------------------------------------------ #
    def __init__(self,
                 collection_area=None,
                 efficiency=None,
                 cadence=None,
                 observation_target=None,
                 random_seed=None,
                 name=None):
        """
        Defines a simple telescope with a variety of properties.
        Can be given a star system for observation to generate a synthetic light curve.

        :param u.Quantity collection_area: Total collection area
        :param float efficiency: Total telescope efficiency
        :param u.Quantity cadence: Data is integrated and binned at this cadence
        :param DeltaStar observation_target: Star system for observation
        :param int random_seed: Optional random seed for this telescope to make results reproducible
        :param str name: Optional name for the telescope
        """

        self._area = None
        if collection_area is not None:
            self.area = collection_area

        self._efficiency = efficiency

        self._cadence = None
        if cadence is not None:
            self.cadence = cadence

        self._observation_target = None
        if observation_target is not None:
            self.observation_target = observation_target

        self._random_seed = None
        if random_seed is not None:
            self.random_seed = random_seed

        if name is None:
            self._name = "Telescope"
        else:
            self._name = name

        self._observation_time = None
        self._observation_total_bins = None
        self._time_domain = None  # np.array of the start-times of each time bin
        self._pure_lightcurve = None  # np.array of the values in the lightcurve, before adding noise
        self._noisy_lightcurve = None  # np.array of the values in the lightcurve after adding noise
        self._all_flares = FlareCollection(0)  # FlareCollection object, generated by star for each observing run

        self._quiescent_intensity_sec = None
        self._quiescent_intensity_sample = None
        if self._area and self._efficiency and self._cadence and self._observation_target:
            self._update_flux()

    # ------------------------------------------------------------------------------------------------------------ #
    def _prep_observations(self, cadence=None):
        if cadence is not None:
            self.cadence = cadence
        if self.cadence is None:
            raise ValueError("A cadence is required to run an observation.")

    #  ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~  #
    def prepare_continuous_observational_run(self, observation_time, cadence=None, print_report=False):
        """
        Prepares to generate a synthetic light curve over a pre-determined period of time.

        :param u.Quantity observation_time: Total observation time
        :param u.Quantity cadence: Observation cadence (will overwrite initialized cadence!)
        :param bool print_report: Whether or not to print() some info about the observation
        :return:
        """
        self.observation_time = observation_time

        self._prep_observations(cadence=cadence)

        #  Determine observational parameters:
        self._time_domain = np.arange(0., observation_time.to(u.s).value, step=self.cadence.to(u.s).value)
        self._observation_total_bins = len(self._time_domain)
        self._update_flux()

        #  Initialize the lightcurves:
        self._pure_lightcurve = np.ones(self._observation_total_bins)*self._quiescent_intensity_sample
        self._noisy_lightcurve = np.zeros(self._observation_total_bins)

        #  Generate flares
        self._all_flares = self._observation_target.generate_flares_over_time(self._observation_time)
        if self._all_flares.num_flares == 0:
            warnings.warn("No flares generated!", AstropyUserWarning)

        if print_report:
            self.observation_report()

    #  ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~   ~~~  #
    def prepare_observe_n_flares(self, num_flares, duration=None, cadence=None):
        """
        Prepares to generate N observable flares.

        If a duration is provided, will include background variability associated with the star's activity.

        :param int num_flares: How many flares to observe
        :param u.Quantity duration: Optional duration, tunes background variability to realistically match
        :param cadence: Observation cadence (will overwrite initialized cadence!)
        :return:
        """
        self._prep_observations(cadence=cadence)
        raise NotImplementedError("This function doesn't work yet!")

    # ------------------------------------------------------------------------------------------------------------ #
    def observation_report(self):
        print(self._name+" total observation time: "+u_str(self._observation_time.to(u.d)))
        print("Quiescent photons/sample: "+u_str(self._quiescent_intensity_sample))
        print("Total number of flares generated: ", self._all_flares.num_flares)

    # ------------------------------------------------------------------------------------------------------------ #
    def _update_flux(self):
        self._quiescent_intensity_sec = self._observation_target.get_flux()*self._area*self._efficiency
        self._quiescent_intensity_sample = self._quiescent_intensity_sec*self._cadence

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def collection_area(self):
        return self._area

    @collection_area.setter
    def collection_area(self, collection_area):
        if isinstance(collection_area, u.Quantity):
            self._area = collection_area.to(u.m2)
        else:
            self._area = u.Quantity(collection_area, unit=u.m2)
            warnings.warn("Casting collection_area, input as "+str(collection_area)+", to mÂ².", AstropyUserWarning)

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def cadence(self):
        return self._cadence

    @cadence.setter
    def cadence(self, cadence):
        if isinstance(cadence, u.Quantity):
            self._cadence = cadence.to(u.s)
        else:
            self._cadence = u.Quantity(cadence, unit=u.s)
            warnings.warn("Casting cadence, input as "+str(cadence)+", to s.", AstropyUserWarning)

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def observation_target(self):
        return self._observation_target

    @observation_target.setter
    def observation_target(self, observation_target):
        if isinstance(observation_target, DeltaStar):
            self._observation_target = observation_target
        else:
            raise TypeError("observation_target must be a DeltaStar or Star class instance")

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def random_seed(self):
        return self._random_seed

    @random_seed.setter
    def random_seed(self, random_seed):
        np.random.seed(random_seed)
        self._random_seed = random_seed

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def observation_time(self):
        return self._observation_time

    @observation_time.setter
    def observation_time(self, observation_time):
        if isinstance(observation_time, u.Quantity):
            self._observation_time = observation_time.to(u.s)
        else:
            self._observation_time = u.Quantity(observation_time, unit=u.s)
            warnings.warn("Casting observation_time, input as "+str(observation_time)+", to s.", AstropyUserWarning)


