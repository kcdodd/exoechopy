
"""
This module provides telescopes for acquiring data.
"""

import warnings

import numpy as np
from pathlib import Path
from astropy import units as u
from astropy.utils.exceptions import AstropyUserWarning

from .stars import *
from .flares.active_regions import *
from ...utils import *

__all__ = ['Telescope']

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #


class Telescope:
    """Basic telescope object for acquiring data from a star system."""

    # ------------------------------------------------------------------------------------------------------------ #
    def __init__(self,
                 collection_area: u.Quantity=None,
                 efficiency: float=None,
                 cadence: u.Quantity=None,
                 observation_target: DeltaStar=None,
                 random_seed: int=None,
                 name: str=None):
        """Defines a simple telescope with a variety of properties.

        Can be given a star system for observation to generate a synthetic light curve.


        Parameters
        ----------
        collection_area
            Total collection area of telescope.  Subtract out an obstructions to collection area.
        efficiency
            Total telescope efficiency, including detectors
        cadence
            Data is integrated and binned at this cadence
        observation_target
            Star system for observation
        random_seed
            Optional random seed for this telescope to make results precisely reproducible
        name
            Optional name for the telescope
        """

        self._area = None
        if collection_area is not None:
            self.collection_area = collection_area

        self._efficiency = efficiency

        self._cadence = None
        if cadence is not None:
            self.cadence = cadence

        self._observation_target = None
        if observation_target is not None:
            self.observation_target = observation_target

        self._random_seed = None
        if random_seed is not None:
            self.random_seed = random_seed

        if name is None:
            self._name = "Telescope"
        else:
            self._name = name

        self._observation_time = None
        self._observation_total_bins = None
        self._time_domain = None  # np.array of the start-times of each time bin
        self._pure_lightcurve = None  # np.array of the values in the lightcurve, before adding noise
        self._background_lightcurve = None  # np.array of the slowly-varying background
        self._noisy_lightcurve = None  # np.array of the values in the lightcurve after adding noise
        self._all_flares = FlareCollection({})  # FlareCollection object, regenerated by star for each observing run

        self._quiescent_intensity_sec = None
        self._quiescent_intensity_sample = None
        if self._area and self._efficiency and self._cadence and self._observation_target:
            self._update_flux()

    # ------------------------------------------------------------------------------------------------------------ #
    def _prep_observations(self, cadence=None):
        if cadence is not None:
            self.cadence = cadence
        if self.cadence is None:
            raise ValueError("A cadence is required to run an observation.")
        self._update_flux()

    def prepare_continuous_observational_run(self,
                                             observation_time: u.Quantity,
                                             cadence: u.Quantity=None,
                                             print_report: bool=False):
        """Prepares to generate a synthetic light curve over a pre-determined period of time.

        Parameters
        ----------
        observation_time
            Total observation time to simulate
        cadence
            Observation cadence (will overwrite initialized cadence!)
        print_report
            Whether or not to print() some info about the observation

        Returns
        -------

        """

        self.observation_time = observation_time

        self._prep_observations(cadence=cadence)

        #  Determine observational parameters:
        self._time_domain = np.arange(0., self.observation_time.to(lw_time_unit).value,
                                      step=self.cadence.to(lw_time_unit).value)*lw_time_unit
        self._observation_total_bins = len(self._time_domain)

        #  Initialize the lightcurves:
        self._pure_lightcurve = np.ones(self._observation_total_bins) * self._quiescent_intensity_sample
        self._background_lightcurve = np.zeros(self._observation_total_bins)
        self._noisy_lightcurve = np.zeros(self._observation_total_bins)

        #  Generate flares
        self._all_flares = self._observation_target.generate_flares_over_time(self._observation_time)
        if self._all_flares.num_flares == 0:
            warnings.warn("No flares generated!", AstropyUserWarning)

        if print_report:
            self.observation_report()

    def prepare_observe_n_flares(self,
                                 num_flares: int,
                                 duration: u.Quantity=None,
                                 cadence: u.Quantity=None):
        """Prepares to generate N observable flares.

        If a duration is provided, will include background variability associated with the star's activity.


        Parameters
        ----------
        num_flares
            How many flares to observe
        duration
            Optional duration, tunes background variability to realistically match
        cadence
            Observation cadence (will overwrite initialized cadence!)

        """
        self._prep_observations(cadence=cadence)
        raise NotImplementedError("This function doesn't work yet!")

    # ------------------------------------------------------------------------------------------------------------ #
    def collect_data(self,
                     output_folder: Path=None,
                     base_filename: str=None):

        # TODO - Make sure to handle delta-function stars!!
        # TODO - Add echoes!!

        flares = self._all_flares.all_flares
        flare_times = self._all_flares.all_flare_times
        flare_positions = self._all_flares.all_flare_vectors
        flare_intensities = self._all_flares.all_flare_intensities
        num_flares = len(flares)

        # Shorten a few commonly used attributes:
        target = self.observation_target
        earth_vect = self.observation_target.earth_direction_vector
        dt = self.cadence

        # A few lists of things that are computed, useful for diagnostics:
        all_earth_flare_angles = np.zeros(num_flares)*u.rad
        earth_flare_visibility = np.zeros(num_flares)

        for f_i, (flare, flare_time, flare_vect, flare_mag) in enumerate(zip(flares,
                                                                             flare_times,
                                                                             flare_positions,
                                                                             flare_intensities)):
            flare_duration = flare.flare_duration
            num_plot_points = max(int(flare_duration/dt), 1)
            # Determine start/stop indices for flare, pad by an index on either side:
            i0 = int(flare_time / dt)-1
            i1 = i0 + num_plot_points + 2
            # Handle edges of lightcurve:
            i0 = max(i0, 0)
            i1 = min(i1, len(self._time_domain))

            local_flare_times = self._time_domain[i0: i1]
            flare_signal = flare.evaluate_over_array(local_flare_times - flare_time) * flare_mag

            earth_flare_angle = angle_between_vectors(earth_vect, flare_vect.value)*u.rad
            all_earth_flare_angles[f_i] = earth_flare_angle

            earth_flare_limb = target.star_limb(earth_flare_angle)
            earth_flare_visibility[f_i] = earth_flare_limb

            self._pure_lightcurve[i0: i1] += flare_signal*earth_flare_limb

        if output_folder is not None:
            output_folder = Path(output_folder)
            np.save(output_folder / (base_filename + " all_earth_flare_angles.npy"), all_earth_flare_angles)
            np.save(output_folder / (base_filename + " earth_flare_visibility.npy"), earth_flare_visibility)
            # To add: Echo lag, echo magnitude, flare location, etc.
            np.save(output_folder / (base_filename + " pure_signal.npy"), self._pure_lightcurve)
            # To add: stellar variability, degraded signals

        return all_earth_flare_angles, earth_flare_visibility

    # ------------------------------------------------------------------------------------------------------------ #
    def observation_report(self):
        print(self._name+" total observation time: "+u_str(self._observation_time.to(u.d)))
        print("Quiescent photons/sample: "+u_str(self._quiescent_intensity_sample))
        print("Total number of flares generated: ", self._all_flares.num_flares)

    # ------------------------------------------------------------------------------------------------------------ #
    def _update_flux(self):
        self._quiescent_intensity_sec = self._observation_target.get_flux()*self._area*self._efficiency
        self._quiescent_intensity_sample = self._quiescent_intensity_sec*self._cadence

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def collection_area(self):
        return self._area

    @collection_area.setter
    def collection_area(self, collection_area):
        if isinstance(collection_area, u.Quantity):
            self._area = collection_area.to("m2")
        else:
            self._area = u.Quantity(collection_area, unit="m2")
            warnings.warn("Casting collection_area, input as "+str(collection_area)+", to m².", AstropyUserWarning)

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def cadence(self):
        return self._cadence

    @cadence.setter
    def cadence(self, cadence):
        if isinstance(cadence, u.Quantity):
            self._cadence = cadence.to(u.s)
        else:
            self._cadence = u.Quantity(cadence, unit=u.s)
            warnings.warn("Casting cadence, input as "+str(cadence)+", to s.", AstropyUserWarning)

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def observation_target(self):
        return self._observation_target

    @observation_target.setter
    def observation_target(self, observation_target):
        if isinstance(observation_target, DeltaStar):
            self._observation_target = observation_target
        else:
            raise TypeError("observation_target must be a DeltaStar or Star class instance")

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def random_seed(self):
        return self._random_seed

    @random_seed.setter
    def random_seed(self, random_seed):
        np.random.seed(random_seed)
        self._random_seed = random_seed

    # ------------------------------------------------------------------------------------------------------------ #
    @property
    def observation_time(self):
        return self._observation_time

    @observation_time.setter
    def observation_time(self, observation_time):
        if isinstance(observation_time, u.Quantity):
            self._observation_time = observation_time.to(u.s)
        else:
            self._observation_time = u.Quantity(observation_time, unit=u.s)
            warnings.warn("Casting observation_time, input as "+str(observation_time)+", to s.", AstropyUserWarning)


